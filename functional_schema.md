# Функциональная схема микросервиса PinokIO

## Обзор
Микросервис PinokIO обрабатывает входящие сообщения от мерчантов и PP, классифицирует их с помощью ИИ и управляет очередями для обеспечения напоминаний в отдельном выходном чате

## Основной поток обработки

### 1. Получение сообщения
```
POST /process_request
├── Проверка авторизации (Bearer token)
├── Валидация IncomingFromMsRequest
```

### 2. Предварительные проверки
```
Входящее сообщение
├── Чат является выходным? → ИГНОРИРОВАТЬ
├── За рамками времени работы? → ИГНОРИРОВАТЬ
├── Это изменение изначального сообщения? → ИГНОРИРОВАТЬ только изменение
└── Проверка соединения с Redis где лежат очереди сообщений
```

### 3. Определение типа пользователя
```
Пользователь
├── В whitelist? → PP (оператор поддержки)
├── Бота определяем как → PP (если bot_enabled = true)
└── Все остальные → MERCHANT (юзер)
```

### 4. Обработка по типу пользователя

#### Если на шаге 3 MERCHANT (юзер)
```
Сообщение от юзера
├── ИИ классификация текста
│   ├── class=1 (требует ответа) → Добавить в Redis очередь
│   └── class=0 (не требует) → ИГНОРИРОВАТЬ
└── Запуск воркера для чата
```

#### Если на шаге 3 PP (оператор поддержки)
```
Сообщение от оператора
├── Добавить в Redis очередь
├── Есть parent_message_id (reply)?
│   ├── ДА → Удалить родительское сообщение из очереди
│   └── НЕТ → Сопоставить с вопросом через ИИ
└── Удалить сопоставленное сообщение из очереди
```

## Система очередей Redis

### Двухуровневая архитектура
```
Краткосрочная очередь (SHORT)
├── stream:chat:{chat_id}
├── Буферизация сообщений от одного мерчанта
├── Окно агрегации: 20 секунд (настраивается)
└── Автоматический перенос в долгосрочную очередь

Долгосрочная очередь (LONG)  
├── stream:chat:{chat_id}:final
├── Финальные агрегированные сообщения
├── Ожидание ответа от pp
└── Мониторинг таймаутов
```

### Логика агрегации
```
Новое сообщение
├── Буфер пуст? → Создать новую серию
├── Тот же автор в окне? → Объединить с серией
├── Другой автор/окно истекло? → Сбросить старую серию
└── Создать новую серию
```

## ИИ компоненты

### 1. Классификатор сообщений
```
Цель: Определить требует ли сообщение ответа
├── Вход: Текст сообщения
├── Критерии: 10+ слов, вопросы, жалобы, упоминания, ссылки, телефоны
├── Выход: {class: 0|1, confidence: 0.0-1.0}
└── class=1 → Требует ответа оператора
```

### 2. Сопоставление ответов
```
Цель: Связать ответ оператора с вопросом клиента
├── Вход: Список вопросов + ответ оператора
├── Критерии: Язык, лексика, семантика, временная близость
├── Выход: {matched_message_id: int|null}
└── Удаление сопоставленного вопроса из очереди
```

## Мониторинг и напоминания

### Система таймаутов
```
Мониторинг каждые N секунд
├── Проверка всех активных чатов
├── Возраст сообщений > таймаут?
│   ├── ДА → Отправить напоминание через Kafka
│   └── НЕТ → Продолжить мониторинг
└── Удаление обработанных сообщений
```

### Контроль тишины в чатах
```
Мониторинг тишины каждые N секунд
├── LONG очередь пуста?
│   ├── ДА → Проверить время последнего уведомления
│   │   ├── прошло > SILENCE_TIMEOUT → Отправить уведомление о тишине
│   │   └── Иначе → Продолжить мониторинг
│   └── НЕТ → Обновить время активности чата
```

### Напоминания
```
Формат напоминания:
├── Получатели: whitelist операторов
├── Текст: "Сообщение от @username висит X секунд"
├── Отправка: HTTP POST → kafka_sender
└── Удаление из очереди после отправки
```

### Уведомления о тишине
```
Формат уведомления о тишине:
├── Получатели: whitelist операторов
├── Текст: "Во входящем чате нет сообщений в очереди уже X секунд"
├── Отправка: HTTP POST → kafka_sender
└── Защита от спама: не чаще чем раз в SILENCE_TIMEOUT секунд
```

## Конфигурация

### Настройки чата
```yaml
chat_id: "уникальный_идентификатор"
settings:
  whitelist: ["@operator1", "@operator2"]  # Операторы PP
  bot_enabled: true                        # Разрешить сообщения от бота
  enabled: true                           # Активен ли чат
  start_time: "07:00"                     # Время начала работы (UTC)
  end_time: "19:00"                       # Время окончания работы (UTC)
  days: [mon, tue, wed, thu, fri]        # Рабочие дни
```

### Redis настройки
```yaml
window_seconds_default: 20    # Окно агрегации сообщений
block_ms: 1000               # Таймаут чтения стрима
interval_ms: 200            # Интервал планировщика
max_batch: 1000             # Максимум чатов за тик
```

### Настройки мониторинга
```yaml
CHECK_INTERVAL: 5            # Интервал проверки (секунды)
MESSAGE_TIMEOUT: 60         # Таймаут висящих сообщений (секунды)
SILENCE_TIMEOUT: 90       # Таймаут тишины в чате (секунды)
```

## Состояния сообщений

```
Входящее сообщение
├── ignored (игнорировано)
│   ├── output_chat (выходной чат)
│   ├── change_message (изменение сообщения)
│   ├── bot_disabled (бот отключен)
│   └── no_response_needed (не требует ответа)
├── blocked (заблокировано)
│   └── time_blocked (время блокировки)
└── in_processing (в обработке)
    └── message_id: redis_stream_id
```

## Состояния контроля тишины

```
Мониторинг тишины
├── Очередь не пуста → Обновить время активности
├── Очередь пуста + прошло > SILENCE_TIMEOUT → Отправить уведомление
└── Очередь пуста + прошло < SILENCE_TIMEOUT → Продолжить мониторинг
```

## Ключевые особенности

1. **Агрегация сообщений**: Объединение последовательных сообщений от одного пользователя
2. **ИИ классификация**: Автоматическое определение необходимости ответа
3. **Умное сопоставление**: Связывание ответов операторов с вопросами клиентов
4. **Мониторинг таймаутов**: Автоматические напоминания о висящих сообщениях
5. **Контроль тишины**: Уведомления о длительном отсутствии активности в чатах
6. **Защита от спама**: Уведомления о тишине не чаще чем раз в SILENCE_TIMEOUT секунд
7. **Гибкая конфигурация**: Настройка времени работы, операторов, параметров агрегации
